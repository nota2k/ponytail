@use "sass:map";
@use "breakpoints" as *;

@mixin fluid-font($min-value, $max-value, $min-vw: $responsive-min-vw, $max-vw: $responsive-max-vw) {
	// Remove units from all inputs
	$min-value-stripped: strip-unit($min-value);
	$max-value-stripped: strip-unit($max-value);
	$min-vw-stripped: strip-unit($min-vw);
	$max-vw-stripped: strip-unit($max-vw);

	// Convert font sizes to rem units (assuming root font size of 16px)
	$min-rem: calc($min-value-stripped / 16);
	$max-rem: calc($max-value-stripped / 16);

	// Calculate the slope (rate of change for vw width) in VW
	$slope: calc(($max-value-stripped - $min-value-stripped) / ($max-vw-stripped - $min-vw-stripped) * 100);

	// Calculate the offset (in rem)
	$offset: calc($min-rem - ((($slope / 100) * $min-vw-stripped) / 16));

	// Output the clamp() value
	font-size: #{$max-rem}rem;

	@media (max-width: $max-vw) {
		font-size: clamp(#{$min-rem}rem, #{$slope}vw + #{$offset}rem, #{$max-rem}rem);
	}
}

@mixin fluid-size($prop, $min-value, $max-value, $min-vw: $responsive-min-vw, $max-vw: $responsive-max-vw) {
	// Remove units from all inputs
	$min-value-stripped: strip-unit($min-value);
	$max-value-stripped: strip-unit($max-value);

	// Resolve named breakpoints if provided
	@if map.has-key($breakpoints, $min-vw) {
		$min-vw: calc(map.get($breakpoints, $min-vw) + 1px);
	}

	@if map.has-key($breakpoints, $max-vw) {
		$max-vw: map.get($breakpoints, $max-vw);
	}

	$min-vw-stripped: strip-unit($min-vw);
	$max-vw-stripped: strip-unit($max-vw);

	// Calculate the slope (rate of change for vw width) in VW
	$slope: calc(($max-value-stripped - $min-value-stripped) / ($max-vw-stripped - $min-vw-stripped) * 100);

	// Calculate the offset (in px)
	$offset: calc($min-value-stripped - (($slope / 100) * $min-vw-stripped));

	// Default case (applies to full responsive range)
	@if $min-vw == $responsive-min-vw and $max-vw == $responsive-max-vw {
		#{$prop}: clamp(#{$min-value-stripped}px, calc(#{$slope}vw + #{$offset}px), #{$max-value-stripped}px);
	}

	// If only the max width is limited
	@else if $min-vw == $responsive-min-vw {
		@media (max-width: #{$max-vw}) {
			#{$prop}: clamp(#{$min-value-stripped}px, calc(#{$slope}vw + #{$offset}px), #{$max-value-stripped}px);
		}
	}

	// If both min and max width are defined
	@else {
		@media (min-width: #{$min-vw}) and (max-width: #{$max-vw}) {
			#{$prop}: clamp(#{$min-value-stripped}px, calc(#{$slope}vw + #{$offset}px), #{$max-value-stripped}px);
		}
	}
}


@mixin visually-hidden {
	position: absolute;
	width: 1px;
	height: 1px;
	padding: 0;
	margin: -1px;
	overflow: hidden;
	clip: rect(0,0,0,0);
	border: 0;
}

@mixin visually-hidden-focusable() {
	&:not(:focus, :focus-within) {
		@include visually-hidden;
	}
}

@mixin clear-bottom-margin {
	&:last-child {
		margin-bottom: 0;
	}
}

@mixin clearfix {
	content: '';
	line-height: 0;
	display: table;
	clear: both;
}

@mixin breakpoint-up($name, $breakpoints: $breakpoints) {
	$min: breakpoint-min($name, $breakpoints);

	@media (min-width: $min) {
		@content;
	}
}

@mixin breakpoint-down($name, $breakpoints: $breakpoints) {
	$max: breakpoint-max($name, $breakpoints);

	@if $max == 767px {
		@media (max-width: $max), screen and (max-width: $responsive-ios) and (orientation: landscape) {
			@content;
		}
	} @else {
		@media (max-width: $max) {
			@content;
		}
	}
}

@mixin breakpoint-between($lower, $upper, $breakpoints: $breakpoints) {
	$min: breakpoint-min($lower, $breakpoints);
	$max: breakpoint-max($upper, $breakpoints);

	@media (min-width: $min) and (max-width: $max) {
		@content;
	}
}

@mixin hover {
	@media (hover: hover) AND (pointer: fine) {
		&:where(:hover, :focus-visible) {
			@content;
		}
	}
}

@mixin has-hover {
	@media (hover: hover) AND (pointer: fine) {
		&:where(:has(a:hover, a:focus-visible)) {
			@content;
		}
	}
}

@mixin full-media-background {
	pointer-events: none;
	position: absolute;
	inset: 0;

	img,
	video {
		width: 100%;
		height: 100%;
		object-fit: cover;
	}
}

@mixin editor-carousel($slides-per-view: 1, $gap: 0) {
	> .block-editor-inner-blocks {
		translate: 0;

		> .block-editor-block-list__layout {
			display: flex;
			gap: #{$gap};
			align-items: stretch;
			flex-wrap: nowrap;
			overflow: scroll clip;
		}

		> .block-editor-block-list__layout > .block-editor-block-list__block {
			flex: 0 0 calc(100% / #{$slides-per-view} - #{$gap} / #{$slides-per-view} * (#{$slides-per-view} - 1));
			width: 100%;

			&:only-child,
			&:first-child:has(+ .block-list-appender) {
				flex: 0 0 100%;
			}
		}

		> .block-editor-block-list__layout > .block-editor-block-list__block > .acf-block-component {
			height: 100%;

			> div {
				height: 100%;
			}

			> div > div {
				height: 100%;
			}
		}

		> .block-editor-block-list__layout > .block-list-appender {
			position: fixed;
		}
	}
}

// Styles the current selector in the front-end
// Styles the inner blocks wrapper in the editor
@mixin inner-block-styles {
	body:not(.wp-admin, .editor-styles-wrapper) & {
		@content;
	}

	body.wp-admin & > * > *,
	body.editor-styles-wrapper & > * > * {
		@content;
	}
}

// Styles the current selector in the front-end
// Styles the closest .wp-block element in the editor
@mixin block-styles {
	body:not(.wp-admin, .editor-styles-wrapper) & {
		@content;
	}

	body.wp-admin .wp-block:has(> * > * > * > &),
	body.editor-styles-wrapper .wp-block:has(> * > * > * > &) {
		@content;
	}
}

// Mixin pour une hauteur responsive avec min et max
@mixin responsive-height($min-height: 234px, $max-height: 470px) {
	height: clamp(#{$min-height}, 50vh, #{$max-height});
}
